-- Migration 018: Add Multi-Assignee Support AND Team Groups (FIXED V2 - UUID SUPPORT)
-- Revolutionary features:
-- 1. Multi-assignee tasks with collaborative/individual modes
-- 2. Team/Group system with @mention support
-- 3. Combined assignment to individuals AND groups
-- 4. Individual progress tracking per person

-- Create teams/groups table if it doesn't exist
CREATE TABLE IF NOT EXISTS workspace_teams (
  id SERIAL PRIMARY KEY,
  workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  name VARCHAR(100) NOT NULL, -- e.g. "kitchen-team", "frontend-dev", "marketing"
  display_name VARCHAR(100) NOT NULL, -- e.g. "Kitchen Team", "Frontend Dev", "Marketing"
  description TEXT,
  color VARCHAR(20) DEFAULT 'blue', -- Channel color for team
  created_by VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  is_active BOOLEAN DEFAULT true,
  
  UNIQUE(workspace_id, name)
);

-- Create team memberships table if it doesn't exist
CREATE TABLE IF NOT EXISTS workspace_team_members (
  id SERIAL PRIMARY KEY,
  team_id INTEGER NOT NULL REFERENCES workspace_teams(id) ON DELETE CASCADE,
  user_id VARCHAR(255) NOT NULL,
  role VARCHAR(50) DEFAULT 'member', -- 'member', 'lead', 'admin'
  joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  joined_by VARCHAR(255),
  is_active BOOLEAN DEFAULT true,
  
  UNIQUE(team_id, user_id)
);

-- Add multi-assignee columns to channel_tasks table if they don't exist
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'channel_tasks' AND column_name = 'assignees') THEN
    ALTER TABLE channel_tasks ADD COLUMN assignees JSONB DEFAULT '[]'::jsonb;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'channel_tasks' AND column_name = 'assigned_teams') THEN
    ALTER TABLE channel_tasks ADD COLUMN assigned_teams JSONB DEFAULT '[]'::jsonb;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'channel_tasks' AND column_name = 'assignment_mode') THEN
    ALTER TABLE channel_tasks ADD COLUMN assignment_mode VARCHAR(50) DEFAULT 'collaborative';
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'channel_tasks' AND column_name = 'individual_completions') THEN
    ALTER TABLE channel_tasks ADD COLUMN individual_completions JSONB DEFAULT '{}'::jsonb;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'channel_tasks' AND column_name = 'completion_count') THEN
    ALTER TABLE channel_tasks ADD COLUMN completion_count INTEGER DEFAULT 0;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'channel_tasks' AND column_name = 'requires_individual_response') THEN
    ALTER TABLE channel_tasks ADD COLUMN requires_individual_response BOOLEAN DEFAULT false;
  END IF;
END $$;

-- Create indexes for performance if they don't exist
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_channel_tasks_assignees') THEN
    CREATE INDEX idx_channel_tasks_assignees ON channel_tasks USING gin(assignees);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_channel_tasks_assigned_teams') THEN
    CREATE INDEX idx_channel_tasks_assigned_teams ON channel_tasks USING gin(assigned_teams);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_channel_tasks_assignment_mode') THEN
    CREATE INDEX idx_channel_tasks_assignment_mode ON channel_tasks(assignment_mode);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_channel_tasks_individual_completions') THEN
    CREATE INDEX idx_channel_tasks_individual_completions ON channel_tasks USING gin(individual_completions);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_channel_tasks_completion_progress') THEN
    CREATE INDEX idx_channel_tasks_completion_progress ON channel_tasks(completion_count);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_workspace_teams_workspace_id') THEN
    CREATE INDEX idx_workspace_teams_workspace_id ON workspace_teams(workspace_id);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_workspace_teams_name') THEN
    CREATE INDEX idx_workspace_teams_name ON workspace_teams(workspace_id, name);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_workspace_team_members_team_id') THEN
    CREATE INDEX idx_workspace_team_members_team_id ON workspace_team_members(team_id);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_workspace_team_members_user_id') THEN
    CREATE INDEX idx_workspace_team_members_user_id ON workspace_team_members(user_id);
  END IF;
END $$;

-- Update existing tasks to use new multi-assignee system
UPDATE channel_tasks 
SET assignees = CASE 
  WHEN assigned_to IS NOT NULL 
  THEN jsonb_build_array(assigned_to)
  ELSE '[]'::jsonb
END,
completion_count = CASE 
  WHEN completed_at IS NOT NULL THEN 1
  ELSE 0
END
WHERE assignees = '[]'::jsonb OR assignees IS NULL;

-- Create helper functions (FIXED: Use UUID for task IDs)

-- Function to check if user is assignee (individual or through team)
CREATE OR REPLACE FUNCTION is_task_assignee(task_assignees jsonb, task_teams jsonb, user_id varchar)
RETURNS boolean AS $$
DECLARE
  team_record RECORD;
BEGIN
  -- Check direct assignment
  IF task_assignees ? user_id THEN
    RETURN true;
  END IF;
  
  -- Check team assignments
  FOR team_record IN 
    SELECT jsonb_array_elements_text(task_teams) as team_id
  LOOP
    IF EXISTS (
      SELECT 1 FROM workspace_team_members wtm 
      WHERE wtm.team_id = team_record.team_id::integer 
      AND wtm.user_id = user_id 
      AND wtm.is_active = true
    ) THEN
      RETURN true;
    END IF;
  END LOOP;
  
  RETURN false;
END;
$$ LANGUAGE plpgsql;

-- Function to get all assignee user IDs (individuals + team members)
CREATE OR REPLACE FUNCTION get_all_task_assignees(task_assignees jsonb, task_teams jsonb)
RETURNS json AS $$
DECLARE
  all_users text[] := ARRAY[]::text[];
  individual_users text[];
  team_users text[];
  team_record RECORD;
BEGIN
  -- Get individual assignees
  SELECT ARRAY(SELECT jsonb_array_elements_text(task_assignees)) INTO individual_users;
  IF individual_users IS NOT NULL THEN
    all_users := all_users || individual_users;
  END IF;
  
  -- Get team members
  FOR team_record IN 
    SELECT jsonb_array_elements_text(task_teams) as team_id
  LOOP
    SELECT ARRAY(
      SELECT wtm.user_id 
      FROM workspace_team_members wtm 
      WHERE wtm.team_id = team_record.team_id::integer 
      AND wtm.is_active = true
    ) INTO team_users;
    
    IF team_users IS NOT NULL THEN
      all_users := all_users || team_users;
    END IF;
  END LOOP;
  
  -- Remove duplicates and return as JSON
  SELECT array_agg(DISTINCT user_id) INTO all_users FROM unnest(all_users) as user_id;
  
  RETURN json_build_object(
    'all_assignees', all_users,
    'count', array_length(all_users, 1)
  );
END;
$$ LANGUAGE plpgsql;

-- Enhanced completion progress function with team support
CREATE OR REPLACE FUNCTION get_task_completion_progress(task_assignees jsonb, task_teams jsonb, individual_completions jsonb)
RETURNS json AS $$
DECLARE
  all_assignees_info json;
  total_assignees integer;
  completed_count integer;
  assignee_list text[];
  completed_assignees text[];
  team_info json[] := ARRAY[]::json[];
  team_record RECORD;
BEGIN
  -- Get all assignees (individuals + team members)
  all_assignees_info := get_all_task_assignees(task_assignees, task_teams);
  assignee_list := (all_assignees_info->>'all_assignees')::text[];
  total_assignees := (all_assignees_info->>'count')::integer;
  
  IF total_assignees IS NULL THEN
    total_assignees := 0;
  END IF;
  
  -- Get completed assignees
  SELECT ARRAY(SELECT jsonb_object_keys(individual_completions)) INTO completed_assignees;
  completed_count := array_length(completed_assignees, 1);
  IF completed_count IS NULL THEN
    completed_count := 0;
  END IF;
  
  -- Get team information
  FOR team_record IN 
    SELECT jsonb_array_elements_text(task_teams) as team_id
  LOOP
    SELECT array_append(team_info, json_build_object(
      'id', wt.id,
      'name', wt.name,
      'display_name', wt.display_name,
      'color', wt.color,
      'member_count', (
        SELECT count(*) 
        FROM workspace_team_members wtm 
        WHERE wtm.team_id = wt.id AND wtm.is_active = true
      )
    )) INTO team_info
    FROM workspace_teams wt
    WHERE wt.id = team_record.team_id::integer;
  END LOOP;
  
  RETURN json_build_object(
    'total', total_assignees,
    'completed', completed_count,
    'percentage', CASE 
      WHEN total_assignees > 0 THEN ROUND((completed_count::decimal / total_assignees) * 100, 1)
      ELSE 0
    END,
    'all_assignees', assignee_list,
    'individual_assignees', (SELECT ARRAY(SELECT jsonb_array_elements_text(task_assignees))),
    'teams', team_info,
    'completed_by', completed_assignees,
    'is_fully_complete', completed_count = total_assignees AND total_assignees > 0
  );
END;
$$ LANGUAGE plpgsql;

-- Function to check if user can edit task (with team support)
CREATE OR REPLACE FUNCTION can_user_edit_task(task_assignees jsonb, task_teams jsonb, task_created_by varchar, current_user_id varchar)
RETURNS boolean AS $$
BEGIN
  -- User can edit if:
  -- 1. They created the task
  -- 2. They are directly assigned to the task
  -- 3. They are a member of an assigned team
  
  RETURN (
    task_created_by = current_user_id OR 
    is_task_assignee(task_assignees, task_teams, current_user_id)
  );
END;
$$ LANGUAGE plpgsql;

-- Create function to handle individual task completion (FIXED: Use UUID)
CREATE OR REPLACE FUNCTION mark_task_complete_individual(
  task_id_param uuid,
  user_id_param varchar,
  completion_timestamp_param timestamp DEFAULT CURRENT_TIMESTAMP
)
RETURNS json AS $$
DECLARE
  task_record channel_tasks%ROWTYPE;
  updated_completions jsonb;
  new_completion_count integer;
  progress_result json;
BEGIN
  -- Get current task
  SELECT * INTO task_record FROM channel_tasks WHERE id = task_id_param;
  
  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'Task not found');
  END IF;
  
  -- Check if user is assignee
  IF NOT is_task_assignee(task_record.assignees, task_record.assigned_teams, user_id_param) THEN
    RETURN json_build_object('success', false, 'error', 'User not assigned to this task');
  END IF;
  
  -- Update individual completions
  updated_completions := task_record.individual_completions || 
    jsonb_build_object(user_id_param, completion_timestamp_param);
  
  -- Count completions
  new_completion_count := jsonb_object_length(updated_completions);
  
  -- Update task
  UPDATE channel_tasks 
  SET 
    individual_completions = updated_completions,
    completion_count = new_completion_count,
    completed_at = CASE 
      -- For individual_response mode, mark complete when all assignees done
      WHEN assignment_mode = 'individual_response' THEN
        CASE WHEN new_completion_count = (get_task_completion_progress(assignees, assigned_teams, updated_completions)->>'total')::integer
        THEN completion_timestamp_param
        ELSE completed_at END
      -- For collaborative mode, mark complete immediately  
      ELSE completion_timestamp_param
    END,
    updated_at = CURRENT_TIMESTAMP
  WHERE id = task_id_param;
  
  -- Get updated progress info
  SELECT get_task_completion_progress(assignees, assigned_teams, individual_completions) 
  INTO progress_result
  FROM channel_tasks 
  WHERE id = task_id_param;
  
  RETURN json_build_object(
    'success', true,
    'progress', progress_result,
    'completed_by_user', user_id_param,
    'timestamp', completion_timestamp_param
  );
END;
$$ LANGUAGE plpgsql;

-- Create function to handle individual task un-completion (FIXED: Use UUID)
CREATE OR REPLACE FUNCTION mark_task_incomplete_individual(
  task_id_param uuid,
  user_id_param varchar
)
RETURNS json AS $$
DECLARE
  task_record channel_tasks%ROWTYPE;
  updated_completions jsonb;
  new_completion_count integer;
  progress_result json;
BEGIN
  -- Get current task
  SELECT * INTO task_record FROM channel_tasks WHERE id = task_id_param;
  
  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'Task not found');
  END IF;
  
  -- Remove user from completions
  updated_completions := task_record.individual_completions - user_id_param;
  new_completion_count := jsonb_object_length(updated_completions);
  
  -- Update task
  UPDATE channel_tasks 
  SET 
    individual_completions = updated_completions,
    completion_count = new_completion_count,
    completed_at = CASE 
      WHEN new_completion_count = 0 THEN NULL
      WHEN assignment_mode = 'individual_response' THEN
        CASE WHEN new_completion_count = (get_task_completion_progress(assignees, assigned_teams, updated_completions)->>'total')::integer
        THEN completed_at
        ELSE NULL END
      ELSE completed_at
    END,
    updated_at = CURRENT_TIMESTAMP
  WHERE id = task_id_param;
  
  -- Get updated progress info
  SELECT get_task_completion_progress(assignees, assigned_teams, individual_completions) 
  INTO progress_result
  FROM channel_tasks 
  WHERE id = task_id_param;
  
  RETURN json_build_object(
    'success', true,
    'progress', progress_result,
    'uncompleted_by_user', user_id_param
  );
END;
$$ LANGUAGE plpgsql;

-- Drop and recreate the enhanced view with team support
DROP VIEW IF EXISTS channel_tasks_with_progress;
CREATE VIEW channel_tasks_with_progress AS
SELECT 
  ct.*,
  get_task_completion_progress(ct.assignees, ct.assigned_teams, ct.individual_completions) as progress_info,
  CASE 
    WHEN ct.assignment_mode = 'individual_response' THEN 
      (get_task_completion_progress(ct.assignees, ct.assigned_teams, ct.individual_completions)->>'is_fully_complete')::boolean
    ELSE 
      ct.completed_at IS NOT NULL
  END as is_complete,
  (get_task_completion_progress(ct.assignees, ct.assigned_teams, ct.individual_completions)->>'total')::integer as total_assignees,
  jsonb_array_length(ct.assignees) as individual_assignee_count,
  jsonb_array_length(ct.assigned_teams) as team_count
FROM channel_tasks ct;

-- Drop and recreate user assignments view
DROP VIEW IF EXISTS user_task_assignments;
CREATE VIEW user_task_assignments AS
SELECT DISTINCT
  ct.id as task_id,
  ct.title,
  ct.thread_id,
  u.id as user_id,
  'individual' as assignment_type,
  NULL as team_id,
  NULL as team_name,
  ct.assignment_mode,
  ct.requires_individual_response,
  CASE 
    WHEN ct.individual_completions ? u.id THEN true
    ELSE false
  END as user_completed,
  ct.progress_info,
  ct.is_complete
FROM channel_tasks_with_progress ct
CROSS JOIN LATERAL jsonb_array_elements_text(ct.assignees) as u(id)

UNION ALL

SELECT DISTINCT
  ct.id as task_id,
  ct.title,
  ct.thread_id,
  wtm.user_id,
  'team' as assignment_type,
  wt.id as team_id,
  wt.display_name as team_name,
  ct.assignment_mode,
  ct.requires_individual_response,
  CASE 
    WHEN ct.individual_completions ? wtm.user_id THEN true
    ELSE false
  END as user_completed,
  ct.progress_info,
  ct.is_complete
FROM channel_tasks_with_progress ct
CROSS JOIN LATERAL jsonb_array_elements_text(ct.assigned_teams) as t(id)
JOIN workspace_teams wt ON wt.id = t.id::integer
JOIN workspace_team_members wtm ON wtm.team_id = wt.id AND wtm.is_active = true;

-- Create sample teams for testing (if workspace exists)
INSERT INTO workspace_teams (workspace_id, name, display_name, description, color, created_by) 
SELECT 
  ws.id,
  'kitchen-team',
  'Kitchen Team',
  'Culinary and food service team members',
  'orange',
  'system'
FROM workspaces ws 
WHERE NOT EXISTS (SELECT 1 FROM workspace_teams WHERE name = 'kitchen-team' AND workspace_id = ws.id)
LIMIT 1;

INSERT INTO workspace_teams (workspace_id, name, display_name, description, color, created_by) 
SELECT 
  ws.id,
  'frontend-dev',
  'Frontend Developers',
  'Frontend development team',
  'blue',
  'system'
FROM workspaces ws 
WHERE NOT EXISTS (SELECT 1 FROM workspace_teams WHERE name = 'frontend-dev' AND workspace_id = ws.id)
LIMIT 1;

INSERT INTO workspace_teams (workspace_id, name, display_name, description, color, created_by) 
SELECT 
  ws.id,
  'backend-dev',
  'Backend Developers', 
  'Backend development team',
  'green',
  'system'
FROM workspaces ws 
WHERE NOT EXISTS (SELECT 1 FROM workspace_teams WHERE name = 'backend-dev' AND workspace_id = ws.id)
LIMIT 1;

INSERT INTO workspace_teams (workspace_id, name, display_name, description, color, created_by) 
SELECT 
  ws.id,
  'design-team',
  'Design Team',
  'UI/UX designers and design system maintainers',
  'purple',
  'system'
FROM workspaces ws 
WHERE NOT EXISTS (SELECT 1 FROM workspace_teams WHERE name = 'design-team' AND workspace_id = ws.id)
LIMIT 1;

INSERT INTO workspace_teams (workspace_id, name, display_name, description, color, created_by) 
SELECT 
  ws.id,
  'marketing',
  'Marketing Team',
  'Marketing, content, and outreach team',
  'pink',
  'system'
FROM workspaces ws 
WHERE NOT EXISTS (SELECT 1 FROM workspace_teams WHERE name = 'marketing' AND workspace_id = ws.id)
LIMIT 1;

-- Add constraints for data integrity (use DO blocks to avoid constraint already exists errors)
DO $$ 
BEGIN
  -- Add team name format constraint if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'check_team_name_format'
  ) THEN
    ALTER TABLE workspace_teams ADD CONSTRAINT check_team_name_format CHECK (name ~ '^[a-z0-9-]+$');
  END IF;
  
  -- Add team color constraint if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'check_team_color_valid'
  ) THEN
    ALTER TABLE workspace_teams ADD CONSTRAINT check_team_color_valid CHECK (color IN ('blue', 'green', 'purple', 'orange', 'pink', 'teal', 'indigo', 'red', 'yellow', 'cyan', 'rose', 'violet'));
  END IF;
  
  -- Add member role constraint if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'check_member_role_valid'
  ) THEN
    ALTER TABLE workspace_team_members ADD CONSTRAINT check_member_role_valid CHECK (role IN ('member', 'lead', 'admin'));
  END IF;
  
  -- Add assignment mode constraint if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'check_assignment_mode_valid'
  ) THEN
    ALTER TABLE channel_tasks ADD CONSTRAINT check_assignment_mode_valid CHECK (assignment_mode IN ('collaborative', 'individual_response'));
  END IF;
  
  -- Add completion count constraint if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'check_completion_count_valid'
  ) THEN
    ALTER TABLE channel_tasks ADD CONSTRAINT check_completion_count_valid CHECK (completion_count >= 0);
  END IF;
END $$;

-- Add comments for documentation
COMMENT ON TABLE workspace_teams IS 'Teams/groups that can be assigned tasks and mentioned in chat';
COMMENT ON TABLE workspace_team_members IS 'Membership relationships between users and teams';
COMMENT ON COLUMN channel_tasks.assignees IS 'Array of individual user IDs assigned to this task';
COMMENT ON COLUMN channel_tasks.assigned_teams IS 'Array of team IDs assigned to this task';
COMMENT ON COLUMN channel_tasks.assignment_mode IS 'collaborative: any assignee can complete | individual_response: each assignee must complete separately';
COMMENT ON COLUMN channel_tasks.individual_completions IS 'Object tracking individual completion status: {"user_id": "completion_timestamp"}';
COMMENT ON COLUMN channel_tasks.completion_count IS 'Number of assignees who have marked this task complete';
COMMENT ON COLUMN channel_tasks.requires_individual_response IS 'True if task requires individual responses from each assignee';
